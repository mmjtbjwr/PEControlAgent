#define DYNEventSpecial
#define DYNCallStackData
/* DSblock model generated by Dymola from Modelica model boost_converter
 Dymola Version 2023 (64-bit), 2022-04-13 translated this at Fri Aug  2 14:57:30 2024

   */
#ifndef DYN_MULTINSTANCE
#define DYN_MULTINSTANCE 1
#endif

#include <matrixop.h>
#include "matrixop.c"
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    2
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    82
#define NWP_   45
#define NP_    23
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 2054994367
#define NHash2_ -423012771
#define NHash3_ 575127027
#define NI_    0
#define NRelF_ 4
#define NRel_  5
#define NTim_  2
#define NSamp_ 1
#define NCons_ 0
#define NA_    60
#define SizePre_ 3
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 4
#define NrDymolaTimers_ 0
#define NWhen_ 2
#define NCheckIf_ 0
#define NGlobalHelp_ 17
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="boost_converter";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/17338/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
DYMOLA_STATIC const char*GUIDString="{e9a325c4-da37-4e21-993a-4b8ad0cb3425}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#define FMIStateValueReferencesDef_ 1
DYMOLA_STATIC unsigned int FMIStateValueReferences_[2]={
33554432, 33554433};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,47) = true;
DYNX(W_,69) = 0;
DYNX(W_,48) = true;
DYNX(W_,73) = 0;
DYNX(W_,52) = false;
DYNX(W_,53) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,3) = false;
DYNX(W_,6) = true;
DYNX(W_,7) = 1;
DYNX(W_,8) = true;
DYNX(W_,10) = 1;
DYNX(W_,17) = false;
DYNX(W_,18) = 1;
DYNX(W_,19) = 1;
DYNX(W_,23) = false;
DYNX(W_,24) = 1;
DYNX(W_,25) = 1;
DYNX(W_,27) = false;
DYNX(W_,43) = false;
DYNX(W_,4) = 293.15;
DYNX(W_,12) = 1;
DYNX(W_,28) = false;
DYNX(W_,29) = 2;
DYNX(W_,33) = 1;
DYNX(W_,35) = -1;
DYNX(W_,36) = 0;
DYNX(W_,0) = 0;
DYNX(W_,39) = 0;
DYNX(W_,41) = 0;
DYNX(W_,5) = 293.15;
DYNX(W_,1) = 0.0;
DYNX(W_,2) = 0.0;
DYNX(W_,13) = 0.0;
DYNX(W_,38) = 0.0;
DYNX(W_,26) = 0.0;
DYNX(W_,42) = 0.0;
DYNX(W_,40) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,14) >= DYNX(DP_,15),"pwm.limiter.uMax >= pwm.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,14), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,15),
   true, 0)),")"));
BoundParameterSection
DYNX(W_,9) = DYNX(DP_,7);
DYNX(W_,11) = DYNX(W_,9);
DYNX(W_,14) = DYNX(DP_,1);
DYNX(W_,15) = DYNX(DP_,2);
DYNX(W_,16) = DYNX(DP_,3);
DYNX(W_,20) = DYNX(DP_,4);
DYNX(W_,21) = DYNX(DP_,5);
DYNX(W_,22) = DYNX(DP_,6);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,12),"pwm.f");
DYNX(W_,31) = DYNX(DYNhelp,0);
DYNX(W_,32) = DYNX(DP_,13);
DYNX(W_,34) = DYNX(DYNhelp,0);
DYNX(W_,37) = DYNX(DP_,13);
DYNX(W_,44) = DYNX(DP_,17);
AssertModelica(1+DYNX(DP_,18)*(DYNX(W_,44)-DYNX(DP_,17)) >= 1E-15,
  "1+resistor1.alpha*(resistor1.T_heatPort-resistor1.T_ref) >= 1E-15", 
  "Temperature outside scope of model!");
BoundParameterConstantSection
DYNX(W_,30) = homotopy(IF DYNX(DP_,19) > DYNX(DP_,14) THEN DYNX(DP_,14) ELSE IF 
  DYNX(DP_,19) < DYNX(DP_,15) THEN DYNX(DP_,15) ELSE DYNX(DP_,19), DYNX(DP_,19));
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,54) = DYNX(W_,37);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,54);
DYNX(Aux_,1) = DYNX(W_,55);
DYNX(Aux_,2) = DYNX(W_,52);
DYNX(Aux_,3) = DYNX(W_,53);
InitialSection
InitialSection2
  DYNX(W_,55) = real2integerEvent(divGuarded(DYNTime-DYNX(W_,37),
    "time-pwm.sawtooth.startTime",DYNX(W_,34),"pwm.sawtooth.period"),
    "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0);
  DYNX(W_,54) = DYNX(W_,37)+DYNX(W_,55)*DYNX(W_,34);
DYNX(W_,53) = DYNX(W_,30);
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,54);
DYNX(Aux_,1) = DYNX(W_,55);
InitialSection2
DYNX(W_,52) = DYNX(Aux_,2);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
beginwhenBlock
if (NewParameters_) {
DYNX(DYNhelp,1) = divinvGuarded(DYNX(W_,34),"pwm.sawtooth.period");
}
DYNX(DYNhelp,2) = real2integer(DYNX(DYNhelp,1)*(DYNTime-DYNX(W_,37)));
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,37),
  "time-pwm.sawtooth.startTime",DYNX(W_,34),"pwm.sawtooth.period"),
  "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0) > PRE(DYNX(W_,55), 1),
   0) 
  DYNX(W_,54) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,76) = IF LessTime(DYNX(W_,37), 0) THEN 0 ELSE divGuarded(DYNTime-
  DYNX(W_,54),"time-pwm.sawtooth.T_start",DYNX(W_,34),"pwm.sawtooth.period");
DYNX(W_,50) = PRE(DYNX(W_,53), 2);
DYNX(W_,46) = Less(DYNX(W_,76),"pwm.greaterEqual.u1", DYNX(W_,50),
  "pwm.greaterEqual.u2", 1);
DYNX(W_,45) = DYNX(W_,46) AND DYNX(W_,11);

MixedSystemOfEquations(6, DYNX(DYNhelp,3))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 6 common subexpressions used in 6 expressions */
  /* Of the common subexpressions 6 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,9) = DYNX(W_,15)*DYNX(W_,16);
  DYNX(DYNhelp,10) = DYNX(W_,21)*DYNX(W_,22);
  /* Automatic tearing of linear system of 6 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  DYNX(DYNhelp,11) = IF DYNX(W_,47) THEN 1 ELSE DYNX(W_,14);
  DYNX(DYNhelp,12) = IF DYNX(W_,48) THEN 1 ELSE DYNX(W_,20);
  DYNX(DYNhelp,13) = IF DYNX(W_,47) THEN DYNX(W_,15) ELSE 1;
  DYNX(DYNhelp,14) = IF DYNX(W_,48) THEN DYNX(W_,21) ELSE 1;
  {
  const char*const varnames_[]={"boost.transistor.s", "boost.diode.s"};
  const double nominal_[]={1.0, 1.0};
  DYNX(W_,69)=RememberSimple_(DYNX(W_,69), 0);
  DYNX(W_,73)=RememberSimple_(DYNX(W_,73), 1);
  SolveLinear2by2((-1.0)*DYNX(DYNhelp,11), DYNX(DYNhelp,12), 
  (-1.0)*DYNX(DYNhelp,13),  -DYNX(DYNhelp,14), 
   -(DYNX(X_,1)+DYNX(W_,22)-DYNX(W_,16)),  -(DYNX(X_,0)+(-1.0)*DYNX(DYNhelp,9)-
    DYNX(DYNhelp,10)), &DYNX(W_,69), &DYNX(W_,73), 
  varnames_, &MixedFailFlag_, "simulation.linear[1]");
  }
  DYNX(W_,70) = DYNX(W_,73)*DYNX(DYNhelp,12)+DYNX(W_,22);
  DYNX(W_,59) = DYNX(W_,69)*DYNX(DYNhelp,11)+DYNX(W_,16);
  DYNX(W_,66) = DYNX(W_,69)*DYNX(DYNhelp,13)+DYNX(DYNhelp,9);
  DYNX(W_,62) =  -(DYNX(W_,73)*DYNX(DYNhelp,14)+DYNX(DYNhelp,10));
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,47),"boost.transistor.off", Less(DYNX(W_,69),
    "boost.transistor.s", 0,"0", 2) OR  NOT DYNX(W_,45));
  UpdateVariableNamed(DYNX(W_,48),"boost.diode.off", Less(DYNX(W_,73),
    "boost.diode.s", 0,"0", 3));
  MixedModeInit(2, DYNX(DYNhelp,15))
  ThetaMixedCross(0,2)
  ThetaMixedCross(1,3)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,73), 1)
  UpdateReal(DYNX(W_,70), 2)
  UpdateReal(DYNX(W_,59), 3)
  UpdateReal(DYNX(W_,69), 4)
  UpdateReal(DYNX(W_,66), 5)
  UpdateReal(DYNX(W_,62), 6)
EndMixedSystemOfEquations

DYNX(W_,57) = DYNX(DP_,21)+(IF LessTime(DYNX(DP_,22), 1) THEN 0 ELSE 
  DYNX(DP_,20));
DYNX(W_,56) = DYNX(W_,57)*(1+DYNX(DP_,18)*(DYNX(W_,44)-DYNX(DP_,17)));
 /* Linear system of equations to solve. */
DYNX(W_,79) = RememberSimple_(DYNX(W_,79), 2);
SolveScalarLinear( -DYNX(W_,56)," -resistor1.R_actual",  -DYNX(X_,1),
  " -resistor1.v", DYNX(W_,79),"currentSensor1.p.i");
 /* End of Equation Block */ 

DYNX(W_,77) =  -(DYNX(W_,62)+DYNX(W_,79));
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 3);
SolveScalarLinearParametric( -DYNX(DP_,16)," -capacitor.C",  -DYNX(W_,77),
  " -capacitor.i", DYNX(F_,1),"der(capacitor.v)");
 /* End of Equation Block */ 

DYNX(W_,74) = DYNX(DP_,0)-DYNX(W_,59);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 4);
SolveScalarLinearParametric(DYNX(DP_,10),"inductor.L", DYNX(W_,74),"inductor.v",
   DYNX(F_,0),"der(inductor.i)");
 /* End of Equation Block */ 

DYNX(W_,71) =  -DYNX(W_,62);
DYNX(W_,67) =  -DYNX(W_,66);
DYNX(W_,78) =  -DYNX(W_,77);
DYNX(W_,80) =  -DYNX(W_,79);

AcceptedSection1
DYNX(W_,51) = sampleNew2(DYNX(W_,32), DYNX(W_,31), 0);
beginwhenBlock
whenModelica(real2integerEventMinor(divGuarded(DYNTime-DYNX(W_,37),
  "time-pwm.sawtooth.startTime",DYNX(W_,34),"pwm.sawtooth.period"),
  "(time-pwm.sawtooth.startTime)/pwm.sawtooth.period", 0) > PRE(DYNX(W_,55), 1),
   1) 
  DYNX(W_,55) = PRE(DYNX(W_,55), 1)+1;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelicaS(DYNX(W_,51))
  DYNX(W_,53) = DYNX(W_,30);
endwhenModelica()
endwhenBlock



AcceptedSection2
DYNX(W_,63) = DYNX(W_,77)+DYNX(W_,79);
DYNX(W_,60) =  -(DYNX(W_,63)+DYNX(W_,66));
DYNX(W_,61) = DYNX(W_,59)*DYNX(X_,0);
DYNX(W_,64) = DYNX(X_,1)*DYNX(W_,62);
DYNX(W_,72) =  -DYNX(W_,70)*DYNX(W_,62);
DYNX(W_,68) = DYNX(W_,59)*DYNX(W_,66);
DYNX(W_,65) = DYNX(W_,72)+DYNX(W_,68);
DYNX(W_,75) =  -(DYNX(W_,60)+DYNX(X_,0));
DYNX(W_,81) = DYNX(X_,1)*DYNX(W_,79);
DYNX(W_,49) =  NOT DYNX(W_,46);
beginwhenBlock
whenModelicaS(DYNX(W_,51))
  DYNX(W_,52) = LessEqual(DYNTime,"time", DYNX(W_,32)+DYNX(W_,31)/(double)(2),
    "pwm.zeroOrderHold.startTime+pwm.zeroOrderHold.samplePeriod/2", 4);
endwhenModelica()
endwhenBlock


DYNX(W_,58) =  -DYNX(X_,0);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("constantVoltage.V", "Value of constant voltage [V]", 0, 80, \
0.0,0.0,0.0,0,560)
DeclareAlias2("constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "constantVoltage.V", 1, 7, 0, 0)
DeclareAlias2("constantVoltage.p.v", "Potential at the pin [V]", \
"constantVoltage.V", 1, 7, 0, 4)
DeclareAlias2("constantVoltage.p.i", "Current flowing into the pin [A]", \
"constantVoltage.i", 1, 5, 58, 132)
DeclareVariable("constantVoltage.n.v", "Potential at the pin [V]", 0, 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("constantVoltage.n.i", "Current flowing into the pin [A]", \
"inductor.i", 1, 1, 0, 132)
DeclareVariable("constantVoltage.i", "Current flowing from pin p to pin n [A]", 58,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("boost.RonTransistor", "Transistor closed resistance [Ohm]", 1,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("boost.GoffTransistor", "Transistor opened conductance [S]", 2,\
 1E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("boost.VkneeTransistor", "Transistor threshold voltage [V]", 3,\
 0, 0.0,0.0,0.0,0,560)
DeclareParameter("boost.RonDiode", "Closed diode resistance [Ohm]", 4, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("boost.GoffDiode", "Opened diode conductance [S]", 5, 1E-05, \
0.0,1E+100,0.0,0,560)
DeclareParameter("boost.VkneeDiode", "Diode forward threshold voltage [V]", 6, 0,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("boost.dc_p1.v", "Potential at the pin [V]", 59, 0.0, 0.0,0.0,\
0.0,0,520)
DeclareAlias2("boost.dc_p1.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareVariable("boost.dc_n1.v", "Potential at the pin [V]", 1, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("boost.dc_n1.i", "Current flowing into the pin [A]", 60, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("boost.vDC1", "DC voltage side 1 [V]", "boost.dc_p1.v", 1, 5, 59, 0)
DeclareAlias2("boost.iDC1", "DC current side 1 [A]", "inductor.i", 1, 1, 0, 0)
DeclareVariable("boost.powerDC1", "DC power side 1 [W]", 61, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boost.dc_p2.v", "Potential at the pin [V]", "capacitor.v", 1, 1, 1,\
 4)
DeclareVariable("boost.dc_p2.i", "Current flowing into the pin [A]", 62, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("boost.dc_n2.v", "Potential at the pin [V]", 2, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("boost.dc_n2.i", "Current flowing into the pin [A]", 63, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("boost.vDC2", "DC voltages side 2 [V]", "capacitor.v", 1, 1, 1, 0)
DeclareAlias2("boost.iDC2", "DC current side 2 [A]", "boost.dc_p2.i", 1, 5, 62, 0)
DeclareVariable("boost.powerDC2", "DC power side 2 [W]", 64, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boost.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 3, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boost.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 4, 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("boost.LossPower", "Loss power leaving component via heatPort [W]",\
 65, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boost.T_heatPort", "Temperature of heatPort [K|degC]", 5, \
293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("boost.useConstantEnable", "Disable boolean input and use constantEnable, if true [:#(type=Boolean)]",\
 6, true, 0.0,0.0,0.0,0,515)
DeclareParameter("boost.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 7, true, 0.0,0.0,0.0,0,562)
DeclareVariable("boost.m", "Number of phases [:#(type=Integer)]", 7, 1, 1.0,\
1E+100,0.0,0,517)
DeclareVariable("boost.enableLogic.useConstantEnable", "Disable boolean input and use constantEnable, if true [:#(type=Boolean)]",\
 8, true, 0.0,0.0,0.0,0,515)
DeclareVariable("boost.enableLogic.constantEnable", "Constant enabling of firing signals [:#(type=Boolean)]",\
 9, false, 0.0,0.0,0.0,0,515)
DeclareVariable("boost.enableLogic.m", "Number of phases [:#(type=Integer)]", 10,\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("boost.enableLogic.enableConstantSource.k", "Constant output value [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("boost.enableLogic.enableConstantSource.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "boost.enableLogic.enableConstantSource.k", 1, 5, 11, 65)
DeclareVariable("boost.enableLogic.booleanReplicator.nout", "Number of outputs [:#(type=Integer)]",\
 12, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("boost.enableLogic.booleanReplicator.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "boost.enableLogic.enableConstantSource.k", 1, 5, 11, 65)
DeclareAlias2("boost.enableLogic.booleanReplicator.y[1]", "Connector of Boolean output signals [:#(type=Boolean)]",\
 "boost.enableLogic.enableConstantSource.k", 1, 5, 11, 65)
DeclareAlias2("boost.enableLogic.internalEnable[1]", "m replicated enable signals [:#(type=Boolean)]",\
 "boost.enableLogic.enableConstantSource.k", 1, 5, 11, 65)
DeclareAlias2("boost.andCondition_p.u1", "Connector of first Boolean input signal [:#(type=Boolean)]",\
 "boost.fire_p", 1, 5, 46, 65)
DeclareAlias2("boost.andCondition_p.u2", "Connector of second Boolean input signal [:#(type=Boolean)]",\
 "boost.enableLogic.enableConstantSource.k", 1, 5, 11, 65)
DeclareVariable("boost.andCondition_p.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 45, false, 0.0,0.0,0.0,0,642)
DeclareVariable("boost.fire_p", "Firing signal of positive potential transistor [:#(type=Boolean)]",\
 46, false, 0.0,0.0,0.0,0,642)
DeclareAlias2("boost.transistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "boost.dc_p1.v", 1, 5, 59, 0)
DeclareAlias2("boost.transistor.p.v", "Potential at the pin [V]", \
"boost.dc_p1.v", 1, 5, 59, 4)
DeclareVariable("boost.transistor.p.i", "Current flowing into the pin [A]", 66, \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("boost.transistor.n.v", "Potential at the pin [V]", 13, 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("boost.transistor.n.i", "Current flowing into the pin [A]", 67, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("boost.transistor.i", "Current flowing from pin p to pin n [A]", \
"boost.transistor.p.i", 1, 5, 66, 0)
DeclareVariable("boost.transistor.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 14, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boost.transistor.Goff", "Backward state-off conductance (opened conductance) [S]",\
 15, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boost.transistor.Vknee", "Forward threshold voltage [V]", 16, \
0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boost.transistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 17, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("boost.transistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 8, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("boost.transistor.LossPower", "Loss power leaving component via heatPort [W]",\
 68, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boost.transistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "boost.transistor.T", 1, 7, 8, 0)
DeclareVariable("boost.transistor.off", "Switching state [:#(type=Boolean)]", 47,\
 true, 0.0,0.0,0.0,0,706)
DeclareVariable("boost.transistor.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 69, 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boost.transistor.unitVoltage", "[V]", 18, 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("boost.transistor.unitCurrent", "[A]", 19, 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("boost.transistor.fire", "[:#(type=Boolean)]", "boost.andCondition_p.y", 1,\
 5, 45, 65)
DeclareVariable("boost.diode.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 70, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boost.diode.p.v", "Potential at the pin [V]", "boost.dc_p1.v", 1,\
 5, 59, 4)
DeclareAlias2("boost.diode.p.i", "Current flowing into the pin [A]", \
"boost.diode.i", 1, 5, 71, 132)
DeclareAlias2("boost.diode.n.v", "Potential at the pin [V]", "capacitor.v", 1, 1,\
 1, 4)
DeclareAlias2("boost.diode.n.i", "Current flowing into the pin [A]", \
"boost.dc_p2.i", 1, 5, 62, 132)
DeclareVariable("boost.diode.i", "Current flowing from pin p to pin n [A]", 71, \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boost.diode.Ron", "Forward state-on differential resistance (closed resistance) [Ohm]",\
 20, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boost.diode.Goff", "Backward state-off conductance (opened conductance) [S]",\
 21, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("boost.diode.Vknee", "Forward threshold voltage [V]", 22, 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("boost.diode.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 23, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("boost.diode.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 9, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("boost.diode.LossPower", "Loss power leaving component via heatPort [W]",\
 72, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("boost.diode.T_heatPort", "Temperature of heatPort [K|degC]", \
"boost.diode.T", 1, 7, 9, 0)
DeclareVariable("boost.diode.off", "Switching state [:#(type=Boolean)]", 48, \
true, 0.0,0.0,0.0,0,706)
DeclareVariable("boost.diode.s", "Auxiliary variable for actual position on the ideal diode characteristic [1]",\
 73, 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("boost.diode.unitVoltage", "[V]", 24, 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("boost.diode.unitCurrent", "[A]", 25, 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 74,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inductor.p.v", "Potential at the pin [V]", "constantVoltage.V", 1,\
 7, 0, 4)
DeclareAlias2("inductor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareAlias2("inductor.n.v", "Potential at the pin [V]", "boost.dc_p1.v", 1, 5,\
 59, 4)
DeclareAlias2("inductor.n.i", "Current flowing into the pin [A]", \
"constantVoltage.i", 1, 5, 58, 132)
DeclareState("inductor.i", "Current flowing from pin p to pin n [A]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("inductor.L", "Inductance [H]", 10, 0.001, 0.0,0.0,0.0,0,560)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 26, 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground.p.i", "Current flowing into the pin [A]", 75, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("pwm.useConstantDutyCycle", "Enables constant duty cycle [:#(type=Boolean)]",\
 27, false, 0.0,0.0,0.0,0,515)
DeclareParameter("pwm.constantDutyCycle", "Constant duty cycle", 11, 0.2, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm.f", "Switching frequency [Hz]", 12, 20000, 0.0,0.0,0.0,0,560)
DeclareParameter("pwm.startTime", "Start time [s]", 13, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("pwm.dutyCycle", "Duty cycle", "const3.k", 1, 7, 19, 0)
DeclareAlias2("pwm.fire", "Firing PWM signal [:#(type=Boolean)]", "boost.fire_p", 1,\
 5, 46, 65)
DeclareVariable("pwm.notFire", "Firing PWM signal [:#(type=Boolean)]", 49, false,\
 0.0,0.0,0.0,0,642)
DeclareParameter("pwm.limiter.uMax", "Upper limits of input signals", 14, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("pwm.limiter.uMin", "Lower limits of input signals", 15, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("pwm.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 28, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pwm.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 29, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("pwm.limiter.u", "Connector of Real input signal", "const3.k", 1, 7,\
 19, 0)
DeclareVariable("pwm.limiter.y", "Connector of Real output signal", 30, 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("pwm.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "const3.k", 1, 7, 19, 1024)
DeclareVariable("pwm.greaterEqual.u1", "Connector of first Real input signal", 76,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pwm.greaterEqual.u2", "Connector of second Real input signal", 50,\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("pwm.greaterEqual.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "boost.fire_p", 1, 5, 46, 65)
DeclareVariable("pwm.zeroOrderHold.samplePeriod", "Sample period of component [s]",\
 31, 0.1, 1E-13,1E+100,0.0,0,513)
DeclareVariable("pwm.zeroOrderHold.startTime", "First sample time instant [s]", 32,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm.zeroOrderHold.sampleTrigger", "True, if sample time instant [:#(type=Boolean)]",\
 51, false, 0.0,0.0,0.0,0,2690)
DeclareVariable("pwm.zeroOrderHold.firstTrigger", "Rising edge signals first sample instant [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,2706)
DeclareAlias2("pwm.zeroOrderHold.u", "Connector of Real input signal", \
"pwm.limiter.y", 1, 5, 30, 0)
DeclareAlias2("pwm.zeroOrderHold.y", "Connector of Real output signal", \
"pwm.greaterEqual.u2", 1, 5, 50, 0)
DeclareVariable("pwm.zeroOrderHold.ySample", "", 53, 0, 0.0,0.0,0.0,0,656)
DeclareVariable("pwm.sawtooth.amplitude", "Amplitude of saw tooth", 33, 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("pwm.sawtooth.period", "Time for one period [s]", 34, 1, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("pwm.sawtooth.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 35, -1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pwm.sawtooth.y", "Connector of Real output signal", \
"pwm.greaterEqual.u1", 1, 5, 76, 0)
DeclareVariable("pwm.sawtooth.offset", "Offset of output signal y", 36, 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pwm.sawtooth.startTime", "Output y = offset for time < startTime [s]",\
 37, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pwm.sawtooth.T_start", "Start time of current period [s]", 54, \
0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("pwm.sawtooth.count", "Period count [:#(type=Integer)]", 55, 0, \
0.0,0.0,0.0,0,2692)
DeclareAlias2("pwm.inverse.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "boost.fire_p", 1, 5, 46, 65)
DeclareAlias2("pwm.inverse.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pwm.notFire", 1, 5, 49, 65)
DeclareAlias2("currentSensor.p.v", "Potential at the pin [V]", "boost.dc_p1.v", 1,\
 5, 59, 4)
DeclareAlias2("currentSensor.p.i", "Current flowing into the pin [A]", \
"inductor.i", 1, 1, 0, 132)
DeclareAlias2("currentSensor.n.v", "Potential at the pin [V]", "boost.dc_p1.v", 1,\
 5, 59, 4)
DeclareAlias2("currentSensor.n.i", "Current flowing into the pin [A]", \
"constantVoltage.i", 1, 5, 58, 132)
DeclareAlias2("currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "inductor.i", 1, 1, 0, 0)
DeclareState("capacitor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 1,\
 170, 0.0,0.0,0.0,0,560)
DeclareDerivative("capacitor.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("capacitor.p.v", "Potential at the pin [V]", "capacitor.v", 1, 1, 1,\
 4)
DeclareVariable("capacitor.p.i", "Current flowing into the pin [A]", 77, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("capacitor.n.v", "Potential at the pin [V]", 38, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("capacitor.n.i", "Current flowing into the pin [A]", 78, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("capacitor.i", "Current flowing from pin p to pin n [A]", \
"capacitor.p.i", 1, 5, 77, 0)
DeclareParameter("capacitor.C", "Capacitance [F]", 16, 0.0006, 0.0,1E+100,0.0,0,560)
DeclareAlias2("voltageSensor.p.v", "Potential at the pin [V]", "capacitor.v", 1,\
 1, 1, 4)
DeclareVariable("voltageSensor.p.i", "Current flowing into the pin [A]", 39, 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("voltageSensor.n.v", "Potential at the pin [V]", 40, 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("voltageSensor.n.i", "Current flowing into the pin [A]", 41, 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "capacitor.v", 1, 1, 1, 0)
DeclareAlias2("currentSensor1.p.v", "Potential at the pin [V]", "capacitor.v", 1,\
 1, 1, 4)
DeclareVariable("currentSensor1.p.i", "Current flowing into the pin [A]", 79, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("currentSensor1.n.v", "Potential at the pin [V]", "capacitor.v", 1,\
 1, 1, 4)
DeclareVariable("currentSensor1.n.i", "Current flowing into the pin [A]", 80, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("currentSensor1.i", "Current in the branch from p to n as output signal [A]",\
 "currentSensor1.p.i", 1, 5, 79, 0)
DeclareParameter("resistor1.T_ref", "Reference temperature [K|degC]", 17, 300.15,\
 0.0,1E+100,300.0,0,560)
DeclareParameter("resistor1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 18, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("resistor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
"capacitor.v", 1, 1, 1, 0)
DeclareAlias2("resistor1.p.v", "Potential at the pin [V]", "capacitor.v", 1, 1, 1,\
 4)
DeclareAlias2("resistor1.p.i", "Current flowing into the pin [A]", \
"currentSensor1.p.i", 1, 5, 79, 132)
DeclareVariable("resistor1.n.v", "Potential at the pin [V]", 42, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("resistor1.n.i", "Current flowing into the pin [A]", \
"currentSensor1.n.i", 1, 5, 80, 132)
DeclareAlias2("resistor1.i", "Current flowing from pin p to pin n [A]", \
"currentSensor1.p.i", 1, 5, 79, 0)
DeclareVariable("resistor1.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 43, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 44, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor1.LossPower", "Loss power leaving component via heatPort [W]",\
 81, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor1.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor1.T", 1, 5, 44, 0)
DeclareVariable("resistor1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 56, 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("resistor1.R", "[Ohm]", 57, 0.0, 0.0,0.0,0.0,0,640)
DeclareParameter("const3.k", "Constant output value", 19, 0.5, 0.0,0.0,0.0,0,560)
DeclareAlias2("const3.y", "Connector of Real output signal", "const3.k", 1, 7, 19,\
 0)
DeclareParameter("step1.height", "Height of step [Ohm]", 20, 5, 0.0,0.0,0.0,0,560)
DeclareAlias2("step1.y", "Connector of Real output signal [Ohm]", "resistor1.R", 1,\
 5, 57, 0)
DeclareParameter("step1.offset", "Offset of output signal y [Ohm]", 21, 20, \
0.0,0.0,0.0,0,560)
DeclareParameter("step1.startTime", "Output y = offset for time < startTime [s]",\
 22, 0.5, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preWD(DYNX(W_,45),"boost.andCondition_p.y", false, 0);
pre(DYNX(W_,55),"pwm.sawtooth.count", 0, 1);
pre(DYNX(W_,53),"pwm.zeroOrderHold.ySample", 0, 2);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,73), 0, 1);
DoRemember_(DYNX(W_,69), 0, 0);
DoRemember_(DYNX(W_,79), 0.0, 2);
DoRemember_(DYNX(F_,1), 0.0, 3);
DoRemember_(DYNX(F_,0), 0.0, 4);
EndEqBlock
UpdateQEvaluate(2)
UpdateSampleCounters(1)
EndDataBlock
